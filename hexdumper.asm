; А-12-19 Харитонов Андрей
; Вариант 22
; Программа просмотра произвольного файла в виде дампа.
.286						; модель процессора
.model small				; один сегмент кода, данных и стека 
.stack 100h					; отводим под стек 256 байт 
.data						; начало сегмента данных
	welcome db 'file name:$'	; строка, которая выведется при запуске программы
	error2 db 'file not found$'	; строка об ошибке, что файл не найден
	error3 db 'path not found$'	; строка об ошибке, что путь не найден
	error4 db 'many open files$'	; строка об ошибке, что открыто много файлов
	error5 db 'access is denied$'	; строка об ошибке, что доступ запрещён
	error6 db 'wrong handle$'	; строка об ошибке, что неверный идентификатор
	errorC db 'wrong access mode$'; строка об ошибке, что неправильный режим доступа
	success db 'hex-dump successfully formed$'	; строка, содержащая информацию о том, что hex дамп успешно сформирован
	handle1 dw ?			; здесь будем хранить хэндл считываемого файла
	handle2 dw ?			; здесь будем хранить хэндл файла, куда будет производиться запись
	outfile db 'hex.txt', 0		; имя файла, куда запишем полученный hex-dump
	file db 20				; подготавливаем буфер, первый байт - максимальная длина имени файла
	len db ?				; фактическая длина введеного имени
	buff db 15 dup('$')		; здесь будет храниться имя файла, которое введём
	hex db 16*3 dup('$')		; здесь будет храниться полученная hex строка
	asciiString db 16 dup('$')	; здесь будут храниться ascii символы, как они были прочитаны

.code
	outstring macro string		; макрос для вывода переданной строки
		mov ah, 9			; функция вывода строки
    		mov dx, offset string	; в dx адрес строки
    		int 21h			; выводим сообщение
	endm					; конец макроса

start:					; начало программы
	mov ax, @data			; настраиваем ds на начало сегмента данных
	mov ds, ax

outwelocme:					; вывод строки 'file name:'
	mov ah, 9				; функция вывода строки
	mov dx, offset welcome		; в dx адрес строки
	int 21h				; выводим

inputfilename:				; буферизированный ввод имени файла
	mov ah, 0Ah				; функция считывания строки символов в буфер
	mov dx, offset file		; dx настраиваем на буфер
	int 21h				; считываем

openfiles:					; открываем необходимые файлы
	mov ah, 3Dh				; функция открытия существующего файла
	mov al, 20h				; запрещаем запись в файл, только чтение
	mov dx, offset buff		; ds:dx - адрес файла, в dx кладём имя файла

	mov bl, len				; в bl кладём длину имени файла, которое ввели
	xor bh, bh				; bh обнуляем
	add bx, dx				; прибавляем к bx dx, чтобы переместиться на конец имени файла
	mov byte ptr[bx], 0		; убираем из имени файла ввод Enter-а

	int 21h				; открываем первый файл

	jnc savehandle1			; если не возникло ошибок, то сохраняем первый хэндл
	jmp isError				; иначе идём на выход и говорим об ошибке

	savehandle1:			; сохранение первого хэндла
		mov handle1, ax		; хэндл после открытия в ax - сохраняем

	mov ah, 3Ch				; функция создания нового файла
	mov cx, 0				; cx нужен для установки атрибутов файла
	mov dx, offset outfile		; в dx кладём имя файла, который создадим
	int 21h				; создаём файл

	jnc opennext			; если нет ошибок, то открываем созданный файл
	jmp isError				; иначе идём на выход и говорим об ошибке

opennext:					; открытие созданного файла
	mov ah, 3Dh				; функция открытия существующего файла
	mov al, 1				; только запись
	mov dx, offset outfile		; ds:dx - адрес файла, в dx кладём имя файла 
	int 21h				; открываем второй файл

	jnc savehandle2			; если не возникло ошибок, то сохраняем второй хэндл 
	jmp isError				; иначе идём на выход и говорим об ошибке

	savehandle2:			; сохранение второго хэндла
		mov handle2, ax		; хэндл после открытия в ax - сохраняем

readfile:					; читаем первый файл
	mov ah, 3Fh				; функция чтения из файла
	mov bx, handle1			; в bx идентификатор первого файла
	mov cx, 16				; будем считывать по 16 байт
	mov dx, offset file		; в ds:dx адрес буфера для приёма данных
	int 21h

	cmp ax, 0				; в ax кол-во реально считанных байт, если 0, то файл уже полностью считан
	jnz saveax				; если ax не 0, то запоминаем ax в стеке
	jmp outsucc				; иначе можно идти на выход

saveax:					; сохранение ax для будущей итерации по считанным байтам
	push ax				; запоминаем ax
	cmp ax, cx				; сравниваем ax с cx
	jz prepare				; если ax = cx, то дальше будет еще одна порция данных, не нужно сохранять об этом информацию
	jnz savecode			; если ax != cx, то следующей порции данных не будет, сохраняем специальный код, чтобы об этом потом сообщить
	savecode:				; сохранение кодовой строки
		push 0FFFFh			; сохраняем в стек FFFFh

prepare:					; подготовка к считыванию порции данных
	mov cx, ax				; в cx кладём кол-во считанных байт
	mov si, offset file		; ds:si на источник данных 
	push ds				; перенастравиваем es, так как приёмник находится в сегменте данных
	pop es				; теперь es = ds 
	mov di, offset hex		; es:di на приёмник данных

load:						; загрузка
	lodsb					; загружаем элемент массива
	cmp al,20h 				; сравниваем c пробелом
    	jb  changeSymb 			; если al меньше, чем 20h, то переходим на changeSymb
    	cmp al,7Fh 				; если al равно 7Fh то переходим на changeSymb (7Fh - Delete)
    	jnz toAscii				; иначе переводим символы в ASCII код

changeSymb:
	push ax 				; запоминаем ax (changeSymb служит для замены управляющих символов на точку)
	mov bx, si 				; в bx кладём текущий si
	dec bx 				; уменьшаем bx
	mov al, 2Eh 			; в al кладём символ точки
	mov [bx], al 			; изменяем управляющий символ на точку
	pop ax 				; возвращаем ax
	
toAscii:					; считанные 16-ричные символы будем переводить в ASCII код
	aam 16				; делим на 10h загруженный элемент и помещаем в ah частное, а в al остаток
	cmp al, 0Ah				; сравниваем al с Ah, чтобы знать нужно ли прибавлять 7 для перевода в ASCII код
	jb checkAh				; если меньше, чем Ah, то не добавляем 7
	add al, 7				; иначе прибавляем 7

checkAh:					; аналогично делаем проверку для ah
	xchg ah, al				; меняем местами ah и al
	cmp al, 0Ah				; сравниваем ah, который в al с Ah
	jb toNext				; если меньше Ah, то производим перевод в ASCII, запись и идём к следующему символу
	add al, 7				; иначе прибавляем 7

toNext:					; запись и переход к следующему символу
	add ax, '00'			; переводим в ASCII код
	stosw					; производим запись в hex
	mov al, 20h				; в al кладём код пробела
	stosb					; также производим запись
	loop load				; идём к следующему символу

	pop cx				; достаём cx
	cmp cx, 0FFFFh			; если он оказался равен коду FFFFh, то дальше порции данных не будет
	jz repeatPop			; снова вытаскиваем cx, чтобы достать его истинное значение
	push cx				; запоминаем cx снова для дальнейшей записи в файл
	jnz elseNotPop			; иначе идём дальше

repeatPop:
	pop cx				; достаём cx
	push cx				; снова запоминаем для будущей записи
	push 0FFFFh				; снова кладём в стек комбинацию
	
elseNotPop:
	mov si, offset file		; ds:si на источник данных
	mov di, offset asciiString	; es:di на приёмник данных
loadAscii:
	lodsb
	stosb
	loop loadAscii
	mov al, 0Ah
	stosb
	
outhex:					; подгатавливаемся к выводу в файл полученной комбинации
	pop cx				; достаём cx, который должен быть равен кол-ву считанных символов
	cmp cx, 0FFFFh			; если достали код FFFFh, то ещё раз достаём из стека уже наш cx
	jz returncx				; достаём верный cx
	jnz continue			; иначе идём дальше

returncx:
	pop cx				; достаём cx
	push 0FFFFh				; снова кладём в стек комбинацию

continue:					; продолжаем работать с cx
	mov ax, 3				; в ax кладём множитель 3
	push cx				; запоминаем cx для записи считанных байт, как они были первоначально
	mul cx				; умножаем ax на cx, так как мы записали в 3 раза больше информации (1-ый hex символ, 2-ой hex символ и пробел)
	mov cx, ax				; кладём в cx полученный ax

	mov ah, 40h				; функция записи в файл
	mov bx, handle2			; в bx кладём идентификатор второго файла
	mov dx, offset hex		; в dx кладём адрес начала строки
	int 21h				; производим запись, запишется cx байт

	pop cx				; возвращаем cx
	inc cx				; инкрементируем для чтения символа перевода строки

	mov ah, 40h				; функция записи в файл
	mov bx, handle2			; в bx кладём идентификатор второго файла
	mov dx, offset asciiString	; в dx кладём адрес начала строки
	int 21h				; производим запись, запишется cx байт
	
checkcode:					; проверка не был ли считан весь файл
	pop bx				; достаём из стека информацию и кладём в bx
	cmp bx, 0FFFFh			; сравниваем bx с комбинацией FFFFh
	jz closeFiles			; если больше нет информации, то закрываем файлы
	jmp readfile			; иначе снова считываем

closeFiles:					; иначе закрываем файлы
	mov ah, 3Eh				; функция закрытия файла
	mov bx, handle1			; в bx кладём хэндл первого файла
	int 21h				; закрываем файл
	jc isError				; если возникла ошибка, то сообщаем о ней и выходим

	mov ah, 3Eh				; функция закрытия файла
	mov bx, handle2			; в bx кладём хэндл второго файла
	int 21h				; закрываем файл
	jc isError				; если возникла ошибка, то сообщаем о ней и выходим

outsucc:					; вывод сообщения об успехе
	mov ah, 02h				; функция вывода символа
    	mov dl, 0Ah				; символ переноса строки
    	int 21h				; делаем перенос строки
	outstring success			; сообщаем о том, что hex-dump успешно сформирован

exit:						; завершение работы
	mov ax, 4C00h
	int 21h

isError:					; если есть ошибка, то проверяем о чём она говорит
	push ax				; запоминаем код ошибки
	
	mov ah, 02h				; функция вывода символа
    	mov dl, 0Ah				; символ переноса строки
    	int 21h				; делаем перенос строки
	
	pop ax				; восстанавливаем код ошибки

	iserror2:				; проверяем равен ли код ошибки двойке
		cmp ax, 2			; сравниваем ax с 2
		jnz iserror3		; если не 2, то проверяем ax с 3
		outstring error2		; иначе выводим сообщение об ошибке
	iserror3:				; проверяем равен ли код ошибки тройке
		cmp ax, 3			; сравниваем ax с 3
		jnz iserror4		; если не 3, то проверяем ax с 4
		outstring error3		; иначе выводим сообщение об ошибке
	iserror4:				; проверяем равен ли код ошибки четверке
		cmp ax, 4			; сравниваем ax с 4
		jnz iserror5		; если не 4, то проверяем ax с 5
		outstring error4		; иначе выводим сообщение об ошибке
	iserror5:				; проверяем равен ли код ошибки пятерке
		cmp ax, 5			; сравниваем ax с 5
		jnz iserror6		; если не 5, то проверяем ax с 6
		outstring error5		; иначе выводим сообщение об ошибке
	iserror6:				; проверяем равен ли код ошибки шестерке
		cmp ax, 6			; сравниваем ax с 6
		jnz iserrorC		; если не 6, то проверяем ax с Ch
		outstring error6		; иначе выводим сообщение об ошибке
	iserrorC:				; проверяем равен ли код ошибки Ch
		cmp ax, 0Ch			; сравниваем ax с Ch
		jnz exit			; если не Ch, то выходим из программы
		outstring errorC		; иначе выводим сообщение об ошибке

	jmp exit				; выходим из программы

end start